import FuelSDK
import singer
import json

from suds.transport.https import HttpAuthenticated
from tap_exacttarget.fuel_overrides import tap_exacttarget__getMoreResults

LOGGER = singer.get_logger()

# Defined our own class whose parent is FuelSDK.ET_Client. We found that
# the logic within FuelSDK.ET_Client.refresh_token() wouldn't allow the refresh_token
# to be used correctly so we need to manually set self.refreshKey.
class SFMCClient(FuelSDK.ET_Client):
    #pylint: disable=super-init-not-called
    def __init__(self, config, config_path):
        if config.get('refresh_token'):
            self.refreshKey = config['refresh_token']

        self.config_path = config_path
        self.config = config

        params = {
            'clientid': config['client_id'],
            'clientsecret': config['client_secret']
        }

        if config.get('tenant_subdomain'):
            # For S10+ accounts: https://developer.salesforce.com/docs/atlas.en-us.noversion.mc-apis.meta/mc-apis/your-subdomain-tenant-specific-endpoints.htm
            # Move to OAuth2: https://help.salesforce.com/articleView?id=mc_rn_january_2019_platform_ip_remove_legacy_package_create_ability.htm&type=5
            if config.get('refresh_token'):
                params['useOAuth2Authentication'] = "True"
                params['authenticationurl'] = ('https://{}.auth.marketingcloudapis.com'
                                               .format(config['tenant_subdomain']))
            else:
                params['useOAuth2Authentication'] = "False"
                params['authenticationurl'] = ('https://{}.auth.marketingcloudapis.com/v1/requestToken'
                                               .format(config['tenant_subdomain']))


            LOGGER.debug("Authentication URL is: {}".format(params['authenticationurl']))
            params['soapendpoint'] = ('https://{}.soap.marketingcloudapis.com/Service.asmx'
                                      .format(config['tenant_subdomain']))

        # Call configure_client from the parent class
        self.configure_client(False, params, None)


    # Define our own refresh_token to capture when refresh_token is updated and write it back
    # to the config file.
    def refresh_token(self, force_refresh=False):
        super().refresh_token()

        if 'refresh_token' in self.config and self.config.get('refresh_token') != self.refreshKey:
            LOGGER.info("Refresh Token changed during  refresh_token")
            self.config['refresh_token'] = self.refreshKey
            with open(self.config_path, 'w') as file:
                json.dump(self.config, file, indent=2)

def _get_response_items(response):
    items = response.results

    if 'count' in response.results:
        LOGGER.info('Got {} results.'.format(response.results.get('count')))
        items = response.results.get('items')

    return items


__all__ = ['get_auth_stub', 'request', 'request_from_cursor']


# PUBLIC FUNCTIONS

def get_auth_stub(config, config_path):
    """
    Given a config dict in the format:

        {'clientid': ... your ET client ID ...,
         'clientsecret': ... your ET client secret ...}

    ... return an auth stub to be used when making requests.
    """
    LOGGER.info("Generating auth stub...")

    # Create our SFMC Client which adds functionality to the library's version
    auth_stub = SFMCClient(config, config_path)

    transport = HttpAuthenticated(timeout=int(config.get('request_timeout', 900)))
    auth_stub.soap_client.set_options(
        transport=transport)

    LOGGER.info("Success.")

    return auth_stub


def request(name, selector, auth_stub, search_filter=None, props=None, batch_size=2500):
    """
    Given an object name (`name`), used for logging purposes only,
      a `selector`, for example FuelSDK.ET_ClickEvent,
      an `auth_stub`, generated by `get_auth_stub`,
      an optional `search_filter`,
      and an optional set of `props` (properties), which specifies the fields
        to be returned from this object,

    ... request data from the ExactTarget API using FuelSDK. This function
    returns a generator that will yield all the records returned by the
    request.

    Example `search_filter`:

        {'Property': 'CustomerKey',
         'SimpleOperator': 'equals',
         'Value': 'abcdef'}

    For more on search filters, see:
      https://developer.salesforce.com/docs/atlas.en-us.noversion.mc-apis.meta/mc-apis/using_complex_filter_parts.htm
    """
    cursor = selector()
    cursor.auth_stub = auth_stub

    if props is not None:
        cursor.props = props

    if search_filter is not None:
        cursor.search_filter = search_filter

        LOGGER.info(
            "Making RETRIEVE call to '{}' endpoint with filters '{}'."
            .format(name, search_filter))

    else:
        LOGGER.info(
            "Making RETRIEVE call to '{}' endpoint with no filters."
            .format(name))

    return request_from_cursor(name, cursor, batch_size)


def request_from_cursor(name, cursor, batch_size):
    """
    Given an object name (`name`), used for logging purposes only, and a
    `cursor` provided by FuelSDK, return a generator that yields all the
    items in that cursor.

    Primarily used internally by `request`, but can be used if cursors have
    to be customized. See tap_exacttarget.endpoints.data_extensions for
    an example.
    """
    response = cursor.get()

    if not response.status:
        raise RuntimeError("Request failed with '{}'"
                           .format(response.message))

    for item in _get_response_items(response):
        yield item

    while response.more_results:
        LOGGER.info("Getting more results from '{}' endpoint".format(name))

        # Override call to getMoreResults to add a batch_size parameter
        # response = cursor.getMoreResults()
        response = tap_exacttarget__getMoreResults(cursor, batch_size=batch_size)
        LOGGER.info("Fetched {} results from '{}' endpoint".format(len(response.results), name))

        if not response.status:
            raise RuntimeError("Request failed with '{}'"
                               .format(response.message))

        for item in _get_response_items(response):
            yield item

    LOGGER.info("Done retrieving results from '{}' endpoint".format(name))
